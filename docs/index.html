

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Welcome to the contomo package! &mdash; contomo 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#">
          

          
            
            <img src="_static/contomo.png" class="logo" alt="Logo"/>
          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Welcome to the contomo package!</a><ul>
<li><a class="reference internal" href="#welcome-to-the-contomo-project">Welcome to the CONTOMO project</a></li>
</ul>
</li>
<li><a class="reference internal" href="#installation">Installation</a><ul>
<li><a class="reference internal" href="#anaconda">Anaconda</a></li>
<li><a class="reference internal" href="#pip">pip</a></li>
<li><a class="reference internal" href="#source">source</a></li>
</ul>
</li>
<li><a class="reference internal" href="#documentation">Documentation</a><ul>
<li><a class="reference internal" href="#module-projected_advection_pde">projected_advection_pde</a></li>
<li><a class="reference internal" href="#module-basis">basis</a></li>
<li><a class="reference internal" href="#module-flow_model">flow_model</a></li>
<li><a class="reference internal" href="#module-ray_model">ray_model</a></li>
<li><a class="reference internal" href="#module-sinogram_interpolator">sinogram_interpolator</a></li>
<li><a class="reference internal" href="#module-piecewise_quadratic">piecewise_quadratic</a></li>
<li><a class="reference internal" href="#module-velocity_solver">velocity_solver</a></li>
<li><a class="reference internal" href="#module-phantom">phantom</a></li>
<li><a class="reference internal" href="#module-utils">utils</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">contomo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#">Docs</a> &raquo;</li>
        
      <li>Welcome to the contomo package!</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="toctree-wrapper compound">
</div>
<div class="section" id="welcome-to-the-contomo-package">
<h1>Welcome to the contomo package!<a class="headerlink" href="#welcome-to-the-contomo-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="welcome-to-the-contomo-project">
<h2>Welcome to the CONTOMO project<a class="headerlink" href="#welcome-to-the-contomo-project" title="Permalink to this headline">¶</a></h2>
<p>This is a scientific code originally developed to adress
high speed - sparse data reconstruction in tomography as published <a class="reference external" href="https://domain.invalid/">here</a>:</p>
<p>publication citation, yerar, journal, etc.</p>
<p>The central idea is to view the tomography problem as an
inital value andvection PDE to be propagated in time. Solutions
are obtianed by discretizing the density field in space in finite volume
fashion and for each sought time recovering the driving velocity field through
the projected advection equations using standard iteratove methods.</p>
<p>The package contains support for reconstruction as well as generation of
4d phantoms for numerical experiments.</p>
<p>To learn more about applications, underlying theory and limitations check out
the original publicationalong with the coding example</p>
</div>
</div>
<div class="section" id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="anaconda">
<h2>Anaconda<a class="headerlink" href="#anaconda" title="Permalink to this headline">¶</a></h2>
<p>contomo is installable via anaconda:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">install</span> <span class="n">contomo</span>
</pre></div>
</div>
</div>
<div class="section" id="pip">
<h2>pip<a class="headerlink" href="#pip" title="Permalink to this headline">¶</a></h2>
<p>as well as via pip:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">contomo</span>
</pre></div>
</div>
</div>
<div class="section" id="source">
<h2>source<a class="headerlink" href="#source" title="Permalink to this headline">¶</a></h2>
<p>you may also try and build form the source. In that case first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="o">...</span>
</pre></div>
</div>
<p>next, go to the just downloaded directory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">contomo</span>
</pre></div>
</div>
<p>and install:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">build</span> <span class="n">install</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="documentation">
<h1>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-projected_advection_pde">
<span id="projected-advection-pde"></span><h2>projected_advection_pde<a class="headerlink" href="#module-projected_advection_pde" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="projected_advection_pde.ProjectedAdvectionPDE">
<em class="property">class </em><code class="sig-prename descclassname">projected_advection_pde.</code><code class="sig-name descname">ProjectedAdvectionPDE</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">flow_model</span></em>, <em class="sig-param"><span class="n">ray_model</span></em>, <em class="sig-param"><span class="n">sinogram_interpolator</span></em><span class="sig-paren">)</span><a class="headerlink" href="#projected_advection_pde.ProjectedAdvectionPDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Advection partial differential equation (PDE) projected into sinogram space.</p>
<p>This object defines the partial differential equation to be solved as an
inital value problem. Mathematically, the system of equations to solve are</p>
<div class="math notranslate nohighlight">
\[\dfrac{\partial \rho}{\partial t} = \mathcal{F}[ \rho, v ] \quad\quad (1)\]</div>
<div class="math notranslate nohighlight">
\[\mathcal{P}[ \mathcal{F}[ \rho, v ] ] = \dfrac{\partial g}{\partial t} \quad\quad (2)\]</div>
<p>where <span class="math notranslate nohighlight">\(\partial \rho/\partial t\)</span> is the temporal derivative of a density field <span class="math notranslate nohighlight">\(\rho(x,t)\)</span>,
<span class="math notranslate nohighlight">\(\mathcal{P}[\cdot]\)</span> defines a projection operator, and <span class="math notranslate nohighlight">\(\partial g/\partial t\)</span> is the temporal
derivative of some measured projections, <span class="math notranslate nohighlight">\(g(s,t)\)</span>. Here <span class="math notranslate nohighlight">\(x\)</span> is a real space coordinate and <span class="math notranslate nohighlight">\(s\)</span> a
sinogram space coordinate, <span class="math notranslate nohighlight">\(t\)</span> denotes time. The operator <span class="math notranslate nohighlight">\(\mathcal{F}[\cdot]\)</span> is a
flow model approximation to <span class="math notranslate nohighlight">\(\partial \rho/\partial t\)</span>, driven by and underlying velocity field
<span class="math notranslate nohighlight">\(v(x,t)\)</span>, which in turn is decomposed on a finite basis.</p>
<p>Given the inital value of the field <span class="math notranslate nohighlight">\(\rho(x,t=0)=\rho_0\)</span> and a set of measured
projections <span class="math notranslate nohighlight">\(g(s, t)\)</span>, this class progagates equation (1) in time using some
provided ray model for <span class="math notranslate nohighlight">\(\mathcal{P}[\cdot]\)</span> and flow model <span class="math notranslate nohighlight">\(\mathcal{F}[\cdot]\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>flow_model</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">FlowModel</span></code>) – Object defining the derivatives of density w.r.t time.</p></li>
<li><p><strong>ray_model</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">RayModel</span></code>) – Object defining the transformation from real space to sinogram space.</p></li>
<li><p><strong>sinogram_interpolator</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">RayModel</span></code>) – Object defining the continous derivatives in time of measured sinograms.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="projected_advection_pde.ProjectedAdvectionPDE.flow_model">
<code class="sig-name descname">flow_model</code><a class="headerlink" href="#projected_advection_pde.ProjectedAdvectionPDE.flow_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Object defining the derivatives of density w.r.t time.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FlowModel</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="projected_advection_pde.ProjectedAdvectionPDE.ray_model">
<code class="sig-name descname">ray_model</code><a class="headerlink" href="#projected_advection_pde.ProjectedAdvectionPDE.ray_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Object defining the transformation from real space to sinogram space.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RayModel</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="projected_advection_pde.ProjectedAdvectionPDE.sinogram_interpolator">
<code class="sig-name descname">sinogram_interpolator</code><a class="headerlink" href="#projected_advection_pde.ProjectedAdvectionPDE.sinogram_interpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Object defining the continous derivatives in time of measured sinograms.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">SinogramInterpolator</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="projected_advection_pde.ProjectedAdvectionPDE.get_density_derivative">
<code class="sig-name descname">get_density_derivative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">rho</span></em><span class="sig-paren">)</span><a class="headerlink" href="#projected_advection_pde.ProjectedAdvectionPDE.get_density_derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute right hand side of advection PDE (1) by solving for v(x,t) through (2).</p>
<p>The procedure to approximate the density field temporal derivative can be described
in two steps. First the velocities are recovered by solving, P[ F[ rho, v ] ] = dgdt,
next, F[ rho, v ] can be computed based on the retrived v.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time</strong> (<em>float</em>) – time.</p></li>
<li><p><strong>rho</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – real space density field.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>density field temporal derivative at time <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">shape=rho.shape</span></code>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>drhodt (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="projected_advection_pde.ProjectedAdvectionPDE.load">
<em class="property">classmethod </em><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#projected_advection_pde.ProjectedAdvectionPDE.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a projected advection pde problem from a pickled file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file</strong> (<em>str</em>) – Absolute file path ending with the full filename. The extension
should be “.papde”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="projected_advection_pde.ProjectedAdvectionPDE.propagate_from_initial_value">
<code class="sig-name descname">propagate_from_initial_value</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">initial_volume</span></em>, <em class="sig-param"><span class="n">start_time</span></em>, <em class="sig-param"><span class="n">end_time</span></em>, <em class="sig-param"><span class="n">stepsize</span></em>, <em class="sig-param"><span class="n">velocity_recovery_iterations</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">save_path</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#projected_advection_pde.ProjectedAdvectionPDE.propagate_from_initial_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate the target advection equation in time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_volume</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Density field at starting time.</p></li>
<li><p><strong>start_time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Time at which the initial density field exists.</p></li>
<li><p><strong>end_time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Time at which to stop time integration.</p></li>
<li><p><strong>stepsize</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Duration of time between two integration steps.</p></li>
<li><p><strong>number_of_timesteps</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Number of integration steps to execute.</p></li>
<li><p><strong>velocity_recovery_iterations</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Number of allowed iterations for recovering velocities
in the projected sub-problem.</p></li>
<li><p><strong>verbose</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>, optional) – Print progress and convergence metrics. Defaults to True.</p></li>
<li><p><strong>save_path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>, optional) – Save reconstructed density fields and sinograms to the given
absolute path ending with desired folder name. Defaults to None.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="projected_advection_pde.ProjectedAdvectionPDE.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#projected_advection_pde.ProjectedAdvectionPDE.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the projected advection pde problem by pickling it to disc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file</strong> (<em>str</em>) – Absolute file path ending with the desired filename and no extensions.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-basis">
<span id="basis"></span><h2>basis<a class="headerlink" href="#module-basis" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="basis.Basis">
<em class="property">class </em><code class="sig-prename descclassname">basis.</code><code class="sig-name descname">Basis</code><a class="headerlink" href="#basis.Basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Finite basis used to represent a spatial velocity field.</p>
<p>This object defines can define a basis for a spatial velcoity field, <span class="math notranslate nohighlight">\(v(x,y,z)=[v_x,v_y,v_z]\)</span> as</p>
<div class="math notranslate nohighlight">
\[v_x(x,y,z) = \sum^m_i \alpha_{xi} \varphi_i(x,y,z)\]</div>
<div class="math notranslate nohighlight">
\[v_y(x,y,z) = \sum^m_i \alpha_{yi} \varphi_i(x,y,z)\]</div>
<div class="math notranslate nohighlight">
\[v_z(x,y,z) = \sum^m_i \alpha_{zi} \varphi_i(x,y,z)\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha_{xi},\alpha_{yi},\alpha_{zi}\)</span> are basis coefficent and <span class="math notranslate nohighlight">\(\varphi_i\)</span> basis functions.</p>
<p>Currently the only available implementation is provided through the <a class="reference internal" href="#basis.TetraMesh" title="basis.TetraMesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TetraMesh</span></code></a>
subclass which represents a finite element tetrahedral type basis.</p>
<dl class="py method">
<dt id="basis.Basis.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">dim</span><span class="o">=</span><span class="default_value">'all'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#basis.Basis.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the interpolated value at (x, y, z) using current basis coefficents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – x-coordinates to interpolate for.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – y-coordinates to interpolate for.</p></li>
<li><p><strong>z</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – z-coordinates to interpolate for.</p></li>
<li><p><strong>dim</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>, optional) – What dimension to evaluate basis for. Defaults to “all”
which will return the full vector output. If integer it should be one of 0,1 or 2, representing
x,y and z dimensions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> Function values at (x,y,z) formed by the linear combination of the basis functions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="basis.Basis.coefficents">
<em class="property">property </em><code class="sig-name descname">coefficents</code><a class="headerlink" href="#basis.Basis.coefficents" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis coefficents, shape=(N,3). The value of <code class="docutils literal notranslate"><span class="pre">coefficents[i,d]</span></code>
is that of <span class="math notranslate nohighlight">\(\alpha_{di}\)</span>, <span class="math notranslate nohighlight">\(d=x,y,z\)</span>. i.e for instance <code class="docutils literal notranslate"><span class="pre">coefficents[21,1]</span></code>
corresponds to the mathematical notation <span class="math notranslate nohighlight">\(\alpha_{y21}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="basis.Basis.get_basis">
<code class="sig-name descname">get_basis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">basis_index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#basis.Basis.get_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the values of basis function number basis_index at specified coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>basis_index</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Index of basis function to evaluate.</p></li>
<li><p><strong>x</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – x-coordinates where to render the basis function.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – y-coordinates where to render the basis function.</p></li>
<li><p><strong>z</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – z-coordinates where to render the basis function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> scalar values of the basis function at input specified coordinates <code class="docutils literal notranslate"><span class="pre">X,Y,Z</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="basis.Basis.get_bounding_sphere_radius">
<code class="sig-name descname">get_bounding_sphere_radius</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">basis_index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#basis.Basis.get_bounding_sphere_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a radius on which basis function basis_index is supported.</p>
<p>The basis function has no support outside the return radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>basis_index</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Index of basis function to evaluate.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> Scalar bounding sphere radii.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="basis.Basis.nodal_coordinates">
<em class="property">property </em><code class="sig-name descname">nodal_coordinates</code><a class="headerlink" href="#basis.Basis.nodal_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis coordinates, shape=(N,3), each basis must be parameterised
by a location in space. The value of <code class="docutils literal notranslate"><span class="pre">nodal_coordinates[i,d]</span></code> is the coordinate of the i:th basis
function in dimension d.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="basis.TetraMesh">
<em class="property">class </em><code class="sig-prename descclassname">basis.</code><code class="sig-name descname">TetraMesh</code><a class="headerlink" href="#basis.TetraMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#basis.Basis" title="basis.Basis"><code class="xref py py-class docutils literal notranslate"><span class="pre">basis.Basis</span></code></a></p>
<p>Defines a 3D tetrahedral finite element type basis by subclassing <a class="reference internal" href="#basis.Basis" title="basis.Basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Basis</span></code></a>.</p>
<dl class="py attribute">
<dt id="basis.TetraMesh.coord">
<code class="sig-name descname">coord</code><a class="headerlink" href="#basis.TetraMesh.coord" title="Permalink to this definition">¶</a></dt>
<dd><p>Nodal coordinates, shape=(nenodes, 3). Each row in coord defines the
coordinates of a mesh node.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="basis.TetraMesh.enod">
<code class="sig-name descname">enod</code><a class="headerlink" href="#basis.TetraMesh.enod" title="Permalink to this definition">¶</a></dt>
<dd><p>Tetra element nodes shape=(nelm, nenodes).e.g enod[i,:] gives
the nodal indices of element i.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="basis.TetraMesh.dof">
<code class="sig-name descname">dof</code><a class="headerlink" href="#basis.TetraMesh.dof" title="Permalink to this definition">¶</a></dt>
<dd><p>Per node degrees of freedom, i.e dof[i,:]
gives the degrees of freedom of node i.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="basis.TetraMesh.efaces">
<code class="sig-name descname">efaces</code><a class="headerlink" href="#basis.TetraMesh.efaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Element faces nodal indices, shape=(nelm, nenodes, 3).
e.g efaces[i,j,:] gives the nodal indices of face j of element i.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="basis.TetraMesh.enormals">
<code class="sig-name descname">enormals</code><a class="headerlink" href="#basis.TetraMesh.enormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Element faces outwards normals (nelm, nefaces, 3).
e.g enormals[i,j,:] gives the normal of face j of element i.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="basis.TetraMesh.ecentroids">
<code class="sig-name descname">ecentroids</code><a class="headerlink" href="#basis.TetraMesh.ecentroids" title="Permalink to this definition">¶</a></dt>
<dd><p>Per element centroids, shape=(nelm, 3).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="basis.TetraMesh.eradius">
<code class="sig-name descname">eradius</code><a class="headerlink" href="#basis.TetraMesh.eradius" title="Permalink to this definition">¶</a></dt>
<dd><p>Per element bounding radius, shape=(nelm, 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="basis.TetraMesh.ecmat">
<code class="sig-name descname">ecmat</code><a class="headerlink" href="#basis.TetraMesh.ecmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Per element interpolation matrix, shape=(nelm, 4, 4). When
multiplied on a coordinate array, <code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array([1,x,y,z])</span></code>, the interpolated value
at x,y,z is found, given that x,y,z is contained by the corresponding element.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="basis.TetraMesh.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">Y</span></em>, <em class="sig-param"><span class="n">Z</span></em>, <em class="sig-param"><span class="n">dim</span><span class="o">=</span><span class="default_value">'all'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#basis.TetraMesh.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method overrides <a class="reference internal" href="#basis.Basis.__call__" title="basis.Basis.__call__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Basis.__call__()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="basis.TetraMesh.generate_mesh_from_levelset">
<em class="property">classmethod </em><code class="sig-name descname">generate_mesh_from_levelset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">level_set</span></em>, <em class="sig-param"><span class="n">bounding_radius</span></em>, <em class="sig-param"><span class="n">max_cell_circumradius</span></em>, <em class="sig-param"><span class="n">max_facet_distance</span></em><span class="sig-paren">)</span><a class="headerlink" href="#basis.TetraMesh.generate_mesh_from_levelset" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a mesh from a level set using <a class="reference external" href="https://github.com/nschloe/pygalmesh">the pygalmesh package</a>:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>level_set</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code>) – Level set, level_set(x) should give a negative output on the exterior
of the mesh and positive on the interior.</p></li>
<li><p><strong>bounding_radius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Bounding radius of mesh.</p></li>
<li><p><strong>max_cell_circumradius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Bound for element radii.</p></li>
<li><p><strong>max_facet_distance</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Bound for facet distance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="basis.TetraMesh.generate_mesh_from_numpy_array">
<em class="property">classmethod </em><code class="sig-name descname">generate_mesh_from_numpy_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">array</span></em>, <em class="sig-param"><span class="n">voxel_size</span></em>, <em class="sig-param"><span class="n">max_cell_circumradius</span></em>, <em class="sig-param"><span class="n">max_facet_distance</span></em><span class="sig-paren">)</span><a class="headerlink" href="#basis.TetraMesh.generate_mesh_from_numpy_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a mesh from a numpy array using <a class="reference external" href="https://github.com/nschloe/pygalmesh">the pygalmesh package</a>:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Numpy array to generate mesh from.</p></li>
<li><p><strong>voxel_size</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Dimension of array voxels.</p></li>
<li><p><strong>max_cell_circumradius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Bound for element radii.</p></li>
<li><p><strong>max_facet_distance</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Bound for facet distance.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="basis.TetraMesh.get_bounding_sphere_radius">
<code class="sig-name descname">get_bounding_sphere_radius</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em><span class="sig-paren">)</span><a class="headerlink" href="#basis.TetraMesh.get_bounding_sphere_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>This method overrides <a class="reference internal" href="#basis.Basis.get_bounding_sphere_radius" title="basis.Basis.get_bounding_sphere_radius"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Basis.get_bounding_sphere_radius()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="basis.TetraMesh.move">
<code class="sig-name descname">move</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">displacement</span></em><span class="sig-paren">)</span><a class="headerlink" href="#basis.TetraMesh.move" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the mesh coordinates and any dependent quanteties by nodal displacements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>displacement</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Nodal displacements, <code class="docutils literal notranslate"><span class="pre">shape=coefficents.shape</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="basis.TetraMesh.to_xdmf">
<code class="sig-name descname">to_xdmf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#basis.TetraMesh.to_xdmf" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the tetra mesh to .xdmf paraview readable format for visualisation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Absolute path to save the mesh at (without .xdmf extension)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-flow_model">
<span id="flow-model"></span><h2>flow_model<a class="headerlink" href="#module-flow_model" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="flow_model.FlowModel">
<em class="property">class </em><code class="sig-prename descclassname">flow_model.</code><code class="sig-name descname">FlowModel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rho</span></em>, <em class="sig-param"><span class="n">origin</span></em>, <em class="sig-param"><span class="n">dx</span></em>, <em class="sig-param"><span class="n">velocity_basis</span></em><span class="sig-paren">)</span><a class="headerlink" href="#flow_model.FlowModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Finite Volumes MUSCL scheme reconstruction type flow model.</p>
<p>This object defines a numerical flow model to approximate a flow model operator
<span class="math notranslate nohighlight">\(\mathcal{F}[\cdot]\)</span> such that</p>
<div class="math notranslate nohighlight">
\[\mathcal{F}[ \rho, v ] \approx \dfrac{\partial \rho}{\partial t}\]</div>
<p>where <span class="math notranslate nohighlight">\(\partial \rho/\partial t\)</span> is the temporal derivative of a density field <span class="math notranslate nohighlight">\(\rho(x,t)\)</span>,
<span class="math notranslate nohighlight">\(v(x,t)\)</span> is a velocity field, <span class="math notranslate nohighlight">\(t\)</span> denotes time and <span class="math notranslate nohighlight">\(x\)</span> is a spatial coordinate.</p>
<p>Given a finite basis approximation of <span class="math notranslate nohighlight">\(v(x,t)\)</span> and a current density field <span class="math notranslate nohighlight">\(\rho\)</span> the
flow model defines an approximation to <span class="math notranslate nohighlight">\(\partial \rho/\partial t\)</span> by making use of a
MUSCL finite volumes scheme. For an introduction to MUSCL finite volumes schemes see <a class="reference external" href="https://en.wikipedia.org/wiki/MUSCL_scheme">this wikipedia article</a>:</p>
<p>Specificaly this implementeation uses a superbee limiter function and a mesh with equal cubic cells placed
on an equdistant grid, such that the entire cell mesh forms also a cube in space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rho</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Per cell density field of shape=(N,N,N). Note that the mesh coordinate arrays are reduced
in size since an implicit assumption of zero density boundary on rho is assumed.</p></li>
<li><p><strong>origin</strong> (<em>tuple</em>) – Spatial coordinate of cell located at index (0,0,0) in mesh coordinate
arrays <code class="docutils literal notranslate"><span class="pre">Xi</span></code>, <code class="docutils literal notranslate"><span class="pre">Yi</span></code>, <code class="docutils literal notranslate"><span class="pre">Zi</span></code> .</p></li>
<li><p><strong>dx</strong> (<em>float</em>) – Cell side lenght.</p></li>
<li><p><strong>velocity_basis</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Basis</span></code>) – Velocity field basis that can be called to render vertex velocities.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="flow_model.FlowModel.rho">
<code class="sig-name descname">rho</code><a class="headerlink" href="#flow_model.FlowModel.rho" title="Permalink to this definition">¶</a></dt>
<dd><p>per cell density field of shape=(N,N,N). Note that the mesh coordinate arrays
<code class="docutils literal notranslate"><span class="pre">Xi</span></code>, <code class="docutils literal notranslate"><span class="pre">Yi</span></code>, <code class="docutils literal notranslate"><span class="pre">Zi</span></code> are reduced in size since an implicit assumption of zero density boundary on
rho is assumed. Make sure to pad rho with 2 cells of zero density if this is not the case.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt>
<code class="sig-name descname">Xi,Yi,Zi</code></dt>
<dd><p>Cell mesh x,y,z-coordinates. E.g Xi[i,j,k] is the x-coordinate of cell i,j,k.
Compared to any input density field of shape=(N,N,N) the mesh coordinate array has shape shape=(N-3,N-3,N-3).
For an input density field only cells with indices (2:-2,2:-2,2:-2) will be treated as nonzero.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="flow_model.FlowModel.origin">
<code class="sig-name descname">origin</code><a class="headerlink" href="#flow_model.FlowModel.origin" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatial coordinate of cell located at index (0,0,0) in mesh coordinate
arrays <code class="docutils literal notranslate"><span class="pre">Xi</span></code>, <code class="docutils literal notranslate"><span class="pre">Yi</span></code>, <code class="docutils literal notranslate"><span class="pre">Zi</span></code> .</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="flow_model.FlowModel.dx">
<code class="sig-name descname">dx</code><a class="headerlink" href="#flow_model.FlowModel.dx" title="Permalink to this definition">¶</a></dt>
<dd><p>Cell side lenght.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="flow_model.FlowModel.vertex_gradients">
<code class="sig-name descname">vertex_gradients</code><a class="headerlink" href="#flow_model.FlowModel.vertex_gradients" title="Permalink to this definition">¶</a></dt>
<dd><p>Precomputed vertex gradients of shape=(N-4,N-4,N-4). These may be
set via <a class="reference internal" href="#flow_model.FlowModel.fixate_density_field" title="flow_model.FlowModel.fixate_density_field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fixate_density_field()</span></code></a> and change only with density and not velocity.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="flow_model.FlowModel.velocity_basis">
<code class="sig-name descname">velocity_basis</code><a class="headerlink" href="#flow_model.FlowModel.velocity_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>a velocity field basis that can be called to render vertex velocities.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Basis</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="flow_model.FlowModel.vertex_velocity_matrices">
<code class="sig-name descname">vertex_velocity_matrices</code><a class="headerlink" href="#flow_model.FlowModel.vertex_velocity_matrices" title="Permalink to this definition">¶</a></dt>
<dd><p>Sparse precomputed
matrices enabling fast computation of vertex velocities. Can be set via <a class="reference internal" href="#flow_model.FlowModel.fixate_velocity_basis" title="flow_model.FlowModel.fixate_velocity_basis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fixate_velocity_basis()</span></code></a> to
avoid repeated slow interpolation through the <code class="docutils literal notranslate"><span class="pre">velocity_basis</span></code> . First index in vertex_velocity_matrices is
for dimension and second for positive or negative cell vertex. E.g vertex_velocity_matrices[0][0] gives
a matrix that can render the negative vertex velocity in x-dimension while vertex_velocity_matrices[0][1]
renders the positive vertex velocity  in x-dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="flow_model.FlowModel.fixate_density_field">
<code class="sig-name descname">fixate_density_field</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rho</span></em><span class="sig-paren">)</span><a class="headerlink" href="#flow_model.FlowModel.fixate_density_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the density field values and precompute vertex density gradients.</p>
</dd></dl>

<dl class="py method">
<dt id="flow_model.FlowModel.fixate_velocity_basis">
<code class="sig-name descname">fixate_velocity_basis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#flow_model.FlowModel.fixate_velocity_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Precompute vertex velocity rendering matrices.</p>
<p>This function sets the attribute <code class="docutils literal notranslate"><span class="pre">vertex_velocity_matrices</span></code>. This
computation can be slow but results in great speedups if the same velocity
basis is to be used with the flow model repeatedly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>verbose</strong> (<em>boolean</em>) – Print progress of computation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="flow_model.FlowModel.get_temporal_density_derivatives">
<code class="sig-name descname">get_temporal_density_derivatives</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">get_vertex_velocity_derivatives</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#flow_model.FlowModel.get_temporal_density_derivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute per cell density derivatives with respect to time.</p>
<p>The option <code class="docutils literal notranslate"><span class="pre">get_vertex_velocity_derivatives</span></code> allows for computing the derivatives w.r.t
the vertex velocities.</p>
<div class="math notranslate nohighlight">
\[\dfrac{\partial \mathcal{F}[ \rho, v ]}{\partial v_{x-}},
\dfrac{\partial \mathcal{F}[ \rho, v ]}{\partial v_{x+}},
\dfrac{\partial \mathcal{F}[ \rho, v ]}{\partial v_{y-}},
\dfrac{\partial \mathcal{F}[ \rho, v ]}{\partial v_{y+}},
\dfrac{\partial \mathcal{F}[ \rho, v ]}{\partial v_{z-}},
\dfrac{\partial \mathcal{F}[ \rho, v ]}{\partial v_{z+}},\]</div>
<p>These are usefull to construct further derivaitves of the flow model w.r.t the
velocity basis coefficents.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Computation is based on the attributes <code class="docutils literal notranslate"><span class="pre">rho</span></code> and <code class="docutils literal notranslate"><span class="pre">velocity_basis</span></code> that defines
density and velocity field. These values are meant to be set before calling this
function. By using the <code class="docutils literal notranslate"><span class="pre">fixate_density_field</span></code> and <code class="docutils literal notranslate"><span class="pre">fixate_velocity_basis</span></code>
speedups can be achived.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>get_vertex_velocity_derivatives</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>) – Also compute derivatie w.r.t vertex velocity.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Per cell density derivative with respect to time as a <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> of shape=(N,N,N), and,
optionally the flow model derivative w.r.t vertex velocities as a <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> of
shape=(N,N,N,3,2), where index (i,j,k,axis,sign) gives the vertex velcoity derivative in dimension
axis of sign sign. i.e (i,j,k,2,1) gives the derivative in cell i,j,k w.r.t <span class="math notranslate nohighlight">\(y+\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="flow_model.FlowModel.max_cfl">
<code class="sig-name descname">max_cfl</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#flow_model.FlowModel.max_cfl" title="Permalink to this definition">¶</a></dt>
<dd><p>Return maximum Courant–Friedrichs–Lewy number.</p>
<p>The Courant–Friedrichs–Lewy number, <span class="math notranslate nohighlight">\(C\)</span>, is defined as</p>
<div class="math notranslate nohighlight">
\[C = \dfrac{\Delta t ( \| v_x \|+\| v_y \|+\| v_z \| )}{\Delta x}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta t\)</span> is a time increment,  <span class="math notranslate nohighlight">\(\Delta x\)</span> the size of the cells in the
mesh and <span class="math notranslate nohighlight">\(v_x\)</span>, <span class="math notranslate nohighlight">\(v_y\)</span>, <span class="math notranslate nohighlight">\(v_z\)</span> are the 3d velocities. The Courant–Friedrichs–Lewy number
must always be less than unity for the possibility of stability to exist. For more info
see this <a class="reference external" href="https://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition">wikipedia article</a>:</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is assumed that the <code class="docutils literal notranslate"><span class="pre">velocity_basis</span></code> defines a velocity basis with maximum
Courant–Friedrichs–Lewy number at the basis nodes. This is the case for a Finite
Element type basis. Such a basis property greatly simplifies the computation of
the Courant–Friedrichs–Lewy number, since it is then enough to evaluate the above
formulat at a small finite number of points in space.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dt</strong> (<em>float</em>) – Size of timestep.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(float) maximum Courant–Friedrichs–Lewy number.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-ray_model">
<span id="ray-model"></span><h2>ray_model<a class="headerlink" href="#module-ray_model" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="ray_model.RayModel">
<em class="property">class </em><code class="sig-prename descclassname">ray_model.</code><code class="sig-name descname">RayModel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">volume_shape</span></em>, <em class="sig-param"><span class="n">number_of_detector_pixels</span></em>, <em class="sig-param"><span class="n">angles</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ray_model.RayModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Numerical ray model for projecting 3d volumes, implementation is a wrapper of <a class="reference external" href="https://www.astra-toolbox.com/index.html">the ASTRA-toolbox</a>:</p>
<p>The selected model is parallel3d_vec in the ASTRA documentation and allows for fast GPU accelerated projections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volume_shape</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code>) – Fixed shape of the <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">arrays</span></code> to be traced by the ray model.</p></li>
<li><p><strong>number_of_detector_pixels</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Number of pixels comprising the detector side (square detector)</p></li>
<li><p><strong>angles</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Projection angles in degrees.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="ray_model.RayModel.number_of_detector_pixels">
<code class="sig-name descname">number_of_detector_pixels</code><a class="headerlink" href="#ray_model.RayModel.number_of_detector_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of pixels comprising the detector side (square detector)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="ray_model.RayModel.angles">
<code class="sig-name descname">angles</code><a class="headerlink" href="#ray_model.RayModel.angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Projection angles in degrees.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This implementation uses the indexing convention that an array has
x dimension along axis=0, y along axis=1, z along axis=2 with ascending coordinate
corresponding to ascending index. X-ray is along x (axis=0) and rotation around
z (axis=2). (This is not the default of ASTRA.) Projections plotted with matplotlib
will be as if one sits on the sample and looks at the detector.</p>
</div>
<dl class="py method">
<dt id="ray_model.RayModel.backward_project">
<code class="sig-name descname">backward_project</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ray_model.RayModel.backward_project" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute backprojection from sinogram data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Sinogram to be backprojected, must have same shape
as the output sinogram of <a class="reference internal" href="#ray_model.RayModel.forward_project" title="ray_model.RayModel.forward_project"><code class="xref py py-meth docutils literal notranslate"><span class="pre">forward_project()</span></code></a>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> backprojection.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="ray_model.RayModel.forward_project">
<code class="sig-name descname">forward_project</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">pos</span><span class="o">=</span><span class="default_value">0, 0, 0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#ray_model.RayModel.forward_project" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a forward projection of data translating it by pos.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Data to be projected.</p></li>
<li><p><strong>pos</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code>, optional) – Translation of volume. Defaults to <code class="docutils literal notranslate"><span class="pre">(0,0,0)</span></code>.
This argument is usefull for projecting subvolumes slightly faster.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> sinogram.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-sinogram_interpolator">
<span id="sinogram-interpolator"></span><h2>sinogram_interpolator<a class="headerlink" href="#module-sinogram_interpolator" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="sinogram_interpolator.SinogramInterpolator">
<em class="property">class </em><code class="sig-prename descclassname">sinogram_interpolator.</code><code class="sig-name descname">SinogramInterpolator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sample_times</span></em>, <em class="sig-param"><span class="n">sinogram_timeseries</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sinogram_interpolator.SinogramInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Interpolate a timeseries of sinograms by piecewise quadratic polynomials.</p>
<p>Given a set of pixelated sinograms with fixed dimension in time, this
class defines an interpolation scheme, such that both the sinogram value and
temporal derivatives of any one pixel can be evaluated for an arbitrary timepoint.</p>
<p>Interpolation is executed through <code class="xref py py-obj docutils literal notranslate"><span class="pre">contomo.piecewise_quadratic.PiecewiseQuadratic</span></code> with <cite>bc_start=0</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_times</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Times at which the sinograms where recorded.</p></li>
<li><p><strong>sinogram_timeseries</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Sinogram timeseries of <code class="docutils literal notranslate"><span class="pre">shape=(T,m,n,d)</span></code> where <code class="docutils literal notranslate"><span class="pre">axis=2</span></code>
indexes projections <code class="docutils literal notranslate"><span class="pre">axis=0</span></code> indexes time, and <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code> indexes the pixels of the sinograms.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="sinogram_interpolator.SinogramInterpolator.sample_times">
<code class="sig-name descname">sample_times</code><a class="headerlink" href="#sinogram_interpolator.SinogramInterpolator.sample_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Times at which the sinograms where recorded.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="sinogram_interpolator.SinogramInterpolator.sinogram_timeseries">
<code class="sig-name descname">sinogram_timeseries</code><a class="headerlink" href="#sinogram_interpolator.SinogramInterpolator.sinogram_timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Sinogram timeseries of <code class="docutils literal notranslate"><span class="pre">shape=(T,m,n,d)</span></code> where <code class="docutils literal notranslate"><span class="pre">axis=2</span></code>
indexes projections <code class="docutils literal notranslate"><span class="pre">axis=0</span></code> indexes time, and <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code> indexes the pixels of the sinograms.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sinogram_interpolator.SinogramInterpolator.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">times</span></em>, <em class="sig-param"><span class="n">derivative</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">original</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sinogram_interpolator.SinogramInterpolator.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the interpolation at an arbitrary time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>times</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">iterable</span></code>) – Times at which to evaluate the interpolation.</p></li>
<li><p><strong>derivative</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional) – Order of temporal derivative to evaluate. Defaults to 0.</p></li>
<li><p><strong>original</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, optional) – Use the orignal unmutated sinogram data. This disregards
any sinograms added via <a class="reference internal" href="#sinogram_interpolator.SinogramInterpolator.add_sinograms" title="sinogram_interpolator.SinogramInterpolator.add_sinograms"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_sinograms()</span></code></a> Defaults to False.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Returns</dt><dd><p>(<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) interpolated sinograms at times <code class="docutils literal notranslate"><span class="pre">time</span></code> of <code class="docutils literal notranslate"><span class="pre">shape=(len(times),m,n,d)</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sinogram_interpolator.SinogramInterpolator.add_sinograms">
<code class="sig-name descname">add_sinograms</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">times</span></em>, <em class="sig-param"><span class="n">sinograms</span></em>, <em class="sig-param"><span class="n">resolution</span><span class="o">=</span><span class="default_value">1e-08</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sinogram_interpolator.SinogramInterpolator.add_sinograms" title="Permalink to this definition">¶</a></dt>
<dd><p>Add projections at a series of timepoints points into the spline.</p>
<p>If the specified <code class="docutils literal notranslate"><span class="pre">times</span></code> are closer than <code class="docutils literal notranslate"><span class="pre">resolution</span></code> to already existing time
points in the <code class="docutils literal notranslate"><span class="pre">sinogram_timeseries</span></code> existing sinograms will be replaced.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>times</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">iterable</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Times at which <code class="docutils literal notranslate"><span class="pre">sinograms</span></code> are recorded.</p></li>
<li><p><strong>sinograms</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">iterable</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Sinograms to insert into the timeseries.</p></li>
<li><p><strong>resolution</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional) – Threshold distance in time from existing
sinograms below which existing sinograms will be replaced by new ones.
Defaults to 1e-8.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sinogram_interpolator.SinogramInterpolator.show_fit">
<code class="sig-name descname">show_fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">row</span></em>, <em class="sig-param"><span class="n">projection</span></em>, <em class="sig-param"><span class="n">col</span></em><span class="sig-paren">)</span><a class="headerlink" href="#sinogram_interpolator.SinogramInterpolator.show_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays a simple plot of the spline interpolation for selected pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>row</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of int) – Pixel rows to plot in the sinogram.</p></li>
<li><p><strong>projection</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of int) – Projections to plot.</p></li>
<li><p><strong>col</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of int) – Pixel columns to plot in the sinogram.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-piecewise_quadratic">
<span id="piecewise-quadratic"></span><h2>piecewise_quadratic<a class="headerlink" href="#module-piecewise_quadratic" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="piecewise_quadratic.PiecewiseQuadratic">
<em class="property">class </em><code class="sig-prename descclassname">piecewise_quadratic.</code><code class="sig-name descname">PiecewiseQuadratic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">times</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">bc_start</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#piecewise_quadratic.PiecewiseQuadratic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Interpolate by piecewise quadratic polynomials data from a univariate function.</p>
<p>This class represents a piecewise quadratic polynomial that passes through a series
of (x,y) data points. The resulting continous function will have a continous derivative
with prescribed value of first derivative at the inital data point (x_0,y_0).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>times</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Time points at which the data was collected, <cite>shape=(N,)</cite>.</p></li>
<li><p><strong>data</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – The scalar data values collected at the timepoints, <cite>shape=(N,)</cite>.</p></li>
<li><p><strong>bc_start</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Value of first derivative at times[0]. Defaults to zero.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="piecewise_quadratic.PiecewiseQuadratic.__call__">
<code class="sig-name descname">__call__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">derivative</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#piecewise_quadratic.PiecewiseQuadratic.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the piecewise polynomial or any of its derivatives at input points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">iterable</span></code>) – Time points at which to evaluate the piecewise polynomial.</p></li>
<li><p><strong>derivative</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Order of desired derivative to evaluate. Default is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) the polynomial values at input times.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-velocity_solver">
<span id="velocity-solver"></span><h2>velocity_solver<a class="headerlink" href="#module-velocity_solver" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="velocity_solver.VelocitySolver">
<em class="property">class </em><code class="sig-prename descclassname">velocity_solver.</code><code class="sig-name descname">VelocitySolver</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">flow_model</span></em>, <em class="sig-param"><span class="n">ray_model</span></em>, <em class="sig-param"><span class="n">dt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#velocity_solver.VelocitySolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Iterative solver of the projected advection PDE subproblem in which velocity is recovered.</p>
<p>The system of equations to solve for a fixed time, <span class="math notranslate nohighlight">\(t=t_n\)</span>, is</p>
<div class="math notranslate nohighlight">
\[\mathcal{P}[ \mathcal{F}[ \rho, v ] ] = \dfrac{\partial g}{\partial t}\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho(x,t)\)</span> is a density field, <span class="math notranslate nohighlight">\(\mathcal{P}[\cdot]\)</span> is a projection operator defined
by a ray model, <span class="math notranslate nohighlight">\(\partial g/\partial t\)</span> are the temporal derivatives of some measured projections, <span class="math notranslate nohighlight">\(g(s,t)\)</span>.
Here <span class="math notranslate nohighlight">\(x\)</span> is a real space coordinate and <span class="math notranslate nohighlight">\(s\)</span> a  sinogram space coordinate, <span class="math notranslate nohighlight">\(t\)</span> denotes time.
The operator <span class="math notranslate nohighlight">\(\mathcal{F}[\cdot]\)</span> is a flow model approximation to <span class="math notranslate nohighlight">\(\partial \rho/\partial t\)</span>,
driven by and underlying velocity field <span class="math notranslate nohighlight">\(v(x,t)\)</span>, which in turn is decomposed on a finite basis. This velocity
decomposition is parameterised by some coefficents, <span class="math notranslate nohighlight">\(\alpha_{xi},\alpha_{yi},\alpha_{zi}\)</span> which are the
sought values of the problem.</p>
<p>The problem is solved practically by minimising the least squares scalar cost function <span class="math notranslate nohighlight">\(C\)</span></p>
<div class="math notranslate nohighlight">
\[C = \int_s \bigg(\mathcal{P}[ \mathcal{F}[ \rho, v ] ] - \dfrac{\partial g}{\partial t}\bigg)^2\]</div>
<p>The used solver is the L-BFGS-B as implemented in the <code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code>. For further
details on the solver <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.html">see the scipy docs</a>.</p>
<p>Note that it is possible to override the <a class="reference internal" href="#velocity_solver.VelocitySolver.solve" title="velocity_solver.VelocitySolver.solve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve</span></code></a> method if another method is preffered.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>flow_model</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">FlowModel</span></code>) – Object defining the derivatives of density w.r.t time.</p></li>
<li><p><strong>ray_model</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">RayModel</span></code>) – Object defining the transformation from real space to sinogram space.</p></li>
<li><p><strong>dt</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Intended timestep of the integrator. This is used to check CFL numbers and
defines a feasible domain for the recovered velocity.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="velocity_solver.VelocitySolver.flow_model">
<code class="sig-name descname">flow_model</code><a class="headerlink" href="#velocity_solver.VelocitySolver.flow_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Object defining the derivatives of density w.r.t time.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FlowModel</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="velocity_solver.VelocitySolver.ray_model">
<code class="sig-name descname">ray_model</code><a class="headerlink" href="#velocity_solver.VelocitySolver.ray_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Object defining the transformation from real space to sinogram space.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">RayModel</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="velocity_solver.VelocitySolver.dt">
<code class="sig-name descname">dt</code><a class="headerlink" href="#velocity_solver.VelocitySolver.dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Intended timestep of the integrator. This is used to check CFL numbers and
defines a feasible domain for the recovered velocity.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="velocity_solver.VelocitySolver.optimal_coefficents">
<code class="sig-name descname">optimal_coefficents</code><a class="headerlink" href="#velocity_solver.VelocitySolver.optimal_coefficents" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimal velocity basis coefficents in a LSQ sense.
<code class="docutils literal notranslate"><span class="pre">shape=flow_model.velocity_basis.coefficents.shape</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Current implementation handles CFL violations in the solution by rescaling the final optimal
coefficents, <span class="math notranslate nohighlight">\(\alpha_{xi},\alpha_{yi},\alpha_{zi}\)</span>, such that at any one basis location
the CFL is no longer violated. The return to the feasible domain is executed along lines defined
by the vectors <span class="math notranslate nohighlight">\(\alpha_{xi},\alpha_{yi},\alpha_{zi}\)</span>, i.e, it is not the closest return
which would be the projection unto the <span class="math notranslate nohighlight">\(L1\)</span> ball. Note also that if the basis does not have
maximum CFL at the basis nodal locations, this mehod is invalid.</p>
</div>
<dl class="py method">
<dt id="velocity_solver.VelocitySolver.check_gradient">
<code class="sig-name descname">check_gradient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#velocity_solver.VelocitySolver.check_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot and print numerical and analytical gradients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Velocity basis coefficents in flattened format, i.e
<code class="docutils literal notranslate"><span class="pre">shape=flow_model.velocity_basis.coefficents.flatten().shape</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="velocity_solver.VelocitySolver.cost">
<code class="sig-name descname">cost</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#velocity_solver.VelocitySolver.cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the cost function for a given state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Velocity basis coefficents in flattened format, i.e
<code class="docutils literal notranslate"><span class="pre">shape=flow_model.velocity_basis.coefficents.flatten().shape</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> cost</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="velocity_solver.VelocitySolver.cost_and_gradient">
<code class="sig-name descname">cost_and_gradient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#velocity_solver.VelocitySolver.cost_and_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate both cost and gradient of cost for a given state.</p>
<p>The sought derivatives are</p>
<div class="math notranslate nohighlight">
\[\dfrac{ \partial C }{ \partial \alpha_{xi} },\quad
\dfrac{ \partial C }{ \partial \alpha_{yi} },\quad
\dfrac{ \partial C }{ \partial \alpha_{zi} }\]</div>
<p>where <span class="math notranslate nohighlight">\(C\)</span> is the cost function and <span class="math notranslate nohighlight">\(\alpha\)</span> the velocity basis coefficents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Velocity basis coefficents in flattened format, i.e
<code class="docutils literal notranslate"><span class="pre">shape=flow_model.velocity_basis.coefficents.flatten().shape</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> cost and <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> gradient matching the input, <code class="docutils literal notranslate"><span class="pre">shape=x.shape</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="velocity_solver.VelocitySolver.get_numerical_gradient">
<code class="sig-name descname">get_numerical_gradient</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#velocity_solver.VelocitySolver.get_numerical_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute numerical gradient by finite difference.</p>
<p>The used approximation is</p>
<div class="math notranslate nohighlight">
\[\dfrac{d f}{d x}  = -\dfrac{f(x+2h)-4f(x+h)+3f(x)}{2h}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Velocity basis coefficents in flattened format, i.e
<code class="docutils literal notranslate"><span class="pre">shape=flow_model.velocity_basis.coefficents.flatten().shape</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> numerical approximation of gradient matching the input, <code class="docutils literal notranslate"><span class="pre">shape=x.shape</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="velocity_solver.VelocitySolver.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dgdt</span></em>, <em class="sig-param"><span class="n">inital_guess</span></em>, <em class="sig-param"><span class="n">maxiter</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">print_frequency</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#velocity_solver.VelocitySolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimise cost function by L-BFGS-B.</p>
<p>This method runs the <code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.opimize.minimize</span></code> L-BFGS-B code
and sets the <code class="docutils literal notranslate"><span class="pre">optimal_coefficents</span></code> attribute to the optimal solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dgdt</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Sinogram temporal derivatives at target time, <code class="docutils literal notranslate"><span class="pre">shape=(m,k,n)</span></code>.</p></li>
<li><p><strong>inital_guess</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Initial guess velocity basis coefficents
<code class="docutils literal notranslate"><span class="pre">shape=flow_model.velocity_basis.coefficents.shape</span></code></p></li>
<li><p><strong>maxiter</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of L-BFGS-B iterations.</p></li>
<li><p><strong>verbose</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>, optional) – Print convergence information. Defaults to True.</p></li>
<li><p><strong>print_frequency</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional) – Only if <code class="docutils literal notranslate"><span class="pre">verbose=True</span></code>. Print convergence information
at every <code class="docutils literal notranslate"><span class="pre">print_frequency</span> <span class="pre">iteration</span></code> step. Defaults to 1.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-phantom">
<span id="phantom"></span><h2>phantom<a class="headerlink" href="#module-phantom" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="phantom.DynamicPhantom">
<em class="property">class </em><code class="sig-prename descclassname">phantom.</code><code class="sig-name descname">DynamicPhantom</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">detector_pixel_size</span></em>, <em class="sig-param"><span class="n">number_of_detector_pixels</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.DynamicPhantom" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Density field phantom defined in space and time (4d).</p>
<p>This class defines phantoms that can be measured through a
ray model (<code class="xref py py-obj docutils literal notranslate"><span class="pre">RayModel</span></code>) at arbitrary time points. Phantoms
meta data and measurment can be saved and loaded easily to and from
disc via pickling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>detector_pixel_size</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Size of a single detector pixel (square pixels).</p></li>
<li><p><strong>number_of_detector_pixels</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Number of pixels comprising the detector side (square detector)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="phantom.DynamicPhantom.detector_pixel_size">
<code class="sig-name descname">detector_pixel_size</code><a class="headerlink" href="#phantom.DynamicPhantom.detector_pixel_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of a single detector pixel (square pixels).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="phantom.DynamicPhantom.number_of_detector_pixels">
<code class="sig-name descname">number_of_detector_pixels</code><a class="headerlink" href="#phantom.DynamicPhantom.number_of_detector_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of pixels comprising the detector side (square detector)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="phantom.DynamicPhantom.measurements">
<code class="sig-name descname">measurements</code><a class="headerlink" href="#phantom.DynamicPhantom.measurements" title="Permalink to this definition">¶</a></dt>
<dd><p>List of recorded measurements as dictionaries
with string keys</p>
<p><code class="docutils literal notranslate"><span class="pre">&quot;label&quot;</span></code>     mapping to a custom string label for the measurment.</p>
<p><code class="docutils literal notranslate"><span class="pre">&quot;time&quot;</span></code>      mapping to a float time at which the measurement was recorded.</p>
<p><code class="docutils literal notranslate"><span class="pre">&quot;angles&quot;</span></code>    mapping to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> of angles in degrees at which projections where recorded.</p>
<p><code class="docutils literal notranslate"><span class="pre">&quot;sinogram&quot;</span></code>  mapping to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> sinogram of shape=(n,k,n), where k is number of projections.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">dictionary</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.DynamicPhantom.add_measurement">
<code class="sig-name descname">add_measurement</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">angles</span></em>, <em class="sig-param"><span class="n">label</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.DynamicPhantom.add_measurement" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a measurement to the <code class="docutils literal notranslate"><span class="pre">measurements</span></code> list with a custom label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Label of measurement.</p></li>
<li><p><strong>time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Time at which to evaluate the phantom density field.</p></li>
<li><p><strong>angles</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Projection angles in degrees.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.DynamicPhantom.get_max_cfl">
<code class="sig-name descname">get_max_cfl</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">times</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.DynamicPhantom.get_max_cfl" title="Permalink to this definition">¶</a></dt>
<dd><p>Return phantom maximum Courant–Friedrichs–Lewy number over a series of times.</p>
<p>The Courant–Friedrichs–Lewy number, <span class="math notranslate nohighlight">\(C\)</span>, is defined as</p>
<div class="math notranslate nohighlight">
\[C = \dfrac{\Delta t ( \| v_x \|+\| v_y \|+\| v_z \| )}{\Delta x}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta t\)</span> is a time increment,  <span class="math notranslate nohighlight">\(\Delta x\)</span> the size of the cells in the
mesh and <span class="math notranslate nohighlight">\(v_x\)</span>, <span class="math notranslate nohighlight">\(v_y\)</span>, <span class="math notranslate nohighlight">\(v_z\)</span> are 3d velocities. The Courant–Friedrichs–Lewy number
must always be less than unity for the possibility of stability to exist. For more info
see this <a class="reference external" href="https://en.wikipedia.org/wiki/Courant-Friedrichs-Lewy_condition">wikipedia article</a>:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>times</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Times at which to evaluate the cfl number.</p></li>
<li><p><strong>dt</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Size of timestep.</p></li>
<li><p><strong>dx</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Size of cells.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) maximum Courant–Friedrichs–Lewy number.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.DynamicPhantom.get_measurements_by_label">
<code class="sig-name descname">get_measurements_by_label</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">labels</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.DynamicPhantom.get_measurements_by_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all measurments that have one of the input labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>labels</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of str) – Labels of measurements to return.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>All measurments that have one of the specififed labels.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.DynamicPhantom.get_measurements_by_time">
<code class="sig-name descname">get_measurements_by_time</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">times</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.DynamicPhantom.get_measurements_by_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all measurments that occured at one of the input times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>times</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">iterable</span></code> of float) – Times of measurements to return.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>All measurments that occured at one of the input times.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.DynamicPhantom.get_sinogram">
<code class="sig-name descname">get_sinogram</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">angles</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.DynamicPhantom.get_sinogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute and return sinogram for a given time and angles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Time at which to evaluate the phantom density field.</p></li>
<li><p><strong>angles</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Projection angles in degrees.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> sinogram of <cite>shape=(m,len(angles),n)</cite></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.DynamicPhantom.get_sinograms_by_label">
<code class="sig-name descname">get_sinograms_by_label</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">labels</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.DynamicPhantom.get_sinograms_by_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all sinograms that have one of the input labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>labels</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of str) – Labels of sinograms to return.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>All sinograms that have one of the specififed labels.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.DynamicPhantom.get_sinograms_by_time">
<code class="sig-name descname">get_sinograms_by_time</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">times</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.DynamicPhantom.get_sinograms_by_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all sinograms that occured at one of the input times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>times</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">iterable</span></code> of float) – Times of sinograms to return.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>All sinograms that occured at one of the input times.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.DynamicPhantom.get_sorted_sinograms_times_and_angles">
<code class="sig-name descname">get_sorted_sinograms_times_and_angles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">labels</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.DynamicPhantom.get_sorted_sinograms_times_and_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return, sorted by times, all measurments that have one of the input labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>labels</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of str) – Labels of measurements to return.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>sorted by time <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">arrays</span></code> of all measurments that have one of the specified labels.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.DynamicPhantom.load">
<em class="property">classmethod </em><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.DynamicPhantom.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a phantom from a pickled file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file</strong> (<em>str</em>) – Absolute file path ending with the full filename. The extension
should be “.phantom”.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.DynamicPhantom.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.DynamicPhantom.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the phantom by pickling it to disc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file</strong> (<em>str</em>) – Absolute file path ending with the desired filename and no extensions.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="phantom.Spheres">
<em class="property">class </em><code class="sig-prename descclassname">phantom.</code><code class="sig-name descname">Spheres</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">detector_pixel_size</span></em>, <em class="sig-param"><span class="n">number_of_detector_pixels</span></em>, <em class="sig-param"><span class="n">hypersampling</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.Spheres" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#phantom.DynamicPhantom" title="phantom.DynamicPhantom"><code class="xref py py-class docutils literal notranslate"><span class="pre">phantom.DynamicPhantom</span></code></a></p>
<p>Phantom constructed from a set of analytical spherical objects.</p>
<p>This phantom is constructed by describing a set of spheres and their analytical
trajectory through space and time. Measurments are created by considering the
analytical radon transform of a sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>detector_pixel_size</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Size of a single detector pixel (square pixels).</p></li>
<li><p><strong>number_of_detector_pixels</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Number of pixels comprising the detector side (square detector)</p></li>
<li><p><strong>hypersampling</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional) – Number of hypersampling points per detector pixel to use when creating
analytical sinograms. For instance, <code class="docutils literal notranslate"><span class="pre">hypersampling=3</span></code> will use a 3 by 3 grid of points
at each detector pixel at which the radon transform is evaluated. The resulting projected
value at the detector pixel is then set to the average of these nine evaluated points.
Defaults to unity.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="phantom.Spheres.detector_pixel_size">
<code class="sig-name descname">detector_pixel_size</code><a class="headerlink" href="#phantom.Spheres.detector_pixel_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of a single detector pixel (square pixels).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="phantom.Spheres.number_of_detector_pixels">
<code class="sig-name descname">number_of_detector_pixels</code><a class="headerlink" href="#phantom.Spheres.number_of_detector_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of pixels comprising the detector side (square detector)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="phantom.Spheres.hypersampling">
<code class="sig-name descname">hypersampling</code><a class="headerlink" href="#phantom.Spheres.hypersampling" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of hypersampling points per detector pixel to use when creating
analytical sinograms. For instance, <code class="docutils literal notranslate"><span class="pre">hypersampling=3</span></code> will use a 3 by 3 grid of points
at each detector pixel at which the radon transform is evaluated. The resulting projected
value at the detector pixel is then set to the average of these nine evaluated points.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.Spheres.add_sphere">
<code class="sig-name descname">add_sphere</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">radii</span></em>, <em class="sig-param"><span class="n">density</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.Spheres.add_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a spherical particle to the ensemble defining the phantom.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Spatial x-coordinate of sphere. If callable, <code class="docutils literal notranslate"><span class="pre">x(time)</span></code> should return the
x-coordinate of the sphere at time <code class="docutils literal notranslate"><span class="pre">time</span></code>. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> the sphere coordinate is assumed stationary.</p></li>
<li><p><strong>y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Spatial y-coordinate of sphere. If callable, <code class="docutils literal notranslate"><span class="pre">y(time)</span></code> should return the
y-coordinate of the sphere at time <code class="docutils literal notranslate"><span class="pre">time</span></code>. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> the sphere coordinate is assumed stationary.</p></li>
<li><p><strong>z</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Spatial z-coordinate of sphere. If callable, <code class="docutils literal notranslate"><span class="pre">z(time)</span></code> should return the
z-coordinate of the sphere at time <code class="docutils literal notranslate"><span class="pre">time</span></code>. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> the sphere coordinate is assumed stationary.</p></li>
<li><p><strong>radii</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Radius of sphere. If callable, <code class="docutils literal notranslate"><span class="pre">radii(time)</span></code> should return the
radii of the sphere at time <code class="docutils literal notranslate"><span class="pre">time</span></code>. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> the sphere radii is assumed constant in time.</p></li>
<li><p><strong>density</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Homogenious density of sphere. If callable, <code class="docutils literal notranslate"><span class="pre">radii(time)</span></code> should
return the density of the sphere at time <code class="docutils literal notranslate"><span class="pre">time</span></code>. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> the density is assumed constant in time.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.Spheres.from_DEM_liggghts">
<em class="property">classmethod </em><code class="sig-name descname">from_DEM_liggghts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">absolute_path_to_vtk_files</span></em>, <em class="sig-param"><span class="n">pattern</span></em>, <em class="sig-param"><span class="n">timestepsize</span></em>, <em class="sig-param"><span class="n">translation</span></em>, <em class="sig-param"><span class="n">detector_pixel_size</span></em>, <em class="sig-param"><span class="n">number_of_detector_pixels</span></em>, <em class="sig-param"><span class="n">hypersampling</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.Spheres.from_DEM_liggghts" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a sphere phantom from a series of Discrete Element liggghts simulation output files.</p>
<p>This method allows instantiation of a sphere phantom by providing a directory in which
Discrete Elements liggghts simulations have been saved in .vtk format.
For more information in liggghts DEM simulations see <a class="reference external" href="https://www.cfdem.com/media/DEM/docu/Manual.html">this link</a>:</p>
<p>To provide a continous phantom format, liner interpolation between provided DEM timesteps
is preformed when the phantom is called to be evaluated at an arbitrary timepoint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>absolute_path_to_vtk_files</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>) – Absolute path to directory in which the DEM liggghts
.vtk output files are stored.</p></li>
<li><p><strong>pattern</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>) – Pattern to match in directory absolute_path_to_vtk_files. The files read are
assumed to match the pattern <code class="docutils literal notranslate"><span class="pre">pattern[0]+&quot;[0-9]*&quot;+pattern[1]</span></code>. For instance, the pattern
<code class="docutils literal notranslate"><span class="pre">pattern=[&quot;my_filename_&quot;,&quot;some_file_ending.vtk&quot;]</span></code> will read files such as
<code class="docutils literal notranslate"><span class="pre">my_filename_3810some_file_ending.vtk</span></code> and infer the timestep as <code class="docutils literal notranslate"><span class="pre">3810</span></code>.</p></li>
<li><p><strong>timestepsize</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Time between two timesteps in the DEM simulation.</p></li>
<li><p><strong>translation</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Desired coordinate translation of sphere ensemble.</p></li>
<li><p><strong>detector_pixel_size</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Size of a single detector pixel (square pixels).</p></li>
<li><p><strong>number_of_detector_pixels</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Number of pixels comprising the detector side (square detector)</p></li>
<li><p><strong>hypersampling</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>, optional) – Number of hypersampling points per detector pixel to use when creating
analytical sinograms. For instance, <code class="docutils literal notranslate"><span class="pre">hypersampling=3</span></code> will use a 3 by 3 grid of points
at each detector pixel at which the radon transform is evaluated. The resulting projected
value at the detector pixel is then set to the average of these nine evaluated points.
Defaults to unity.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.Spheres.get_coordinates">
<code class="sig-name descname">get_coordinates</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.Spheres.get_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all sphere coordinates at specified time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – time at which to evaluate the sphere ensemble coordinates.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> of shape=(N,3) with per sphere x,y,z coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.Spheres.get_densities">
<code class="sig-name descname">get_densities</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.Spheres.get_densities" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all sphere densities at specified time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – time at which to evaluate the sphere ensemble coordinates.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> of shape=(N,) with per sphere density.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.Spheres.get_max_cfl">
<code class="sig-name descname">get_max_cfl</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">times</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.Spheres.get_max_cfl" title="Permalink to this definition">¶</a></dt>
<dd><p>This method overrides <code class="xref py py-meth docutils literal notranslate"><span class="pre">Phantom.get_max_cfl()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="phantom.Spheres.get_radii">
<code class="sig-name descname">get_radii</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.Spheres.get_radii" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all sphere radii at specified time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – time at which to evaluate the sphere ensemble coordinates.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> of shape=(N,) with per sphere radius.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.Spheres.get_sinogram">
<code class="sig-name descname">get_sinogram</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">angles</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.Spheres.get_sinogram" title="Permalink to this definition">¶</a></dt>
<dd><p>This method implements <a class="reference internal" href="#phantom.Spheres.get_sinogram" title="phantom.Spheres.get_sinogram"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_sinogram()</span></code></a> of superclass <code class="xref py py-obj docutils literal notranslate"><span class="pre">Phantom</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="phantom.Spheres.to_vtk">
<code class="sig-name descname">to_vtk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">times</span></em>, <em class="sig-param"><span class="n">scale</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">translation</span><span class="o">=</span><span class="default_value">array([0, 0, 0])</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.Spheres.to_vtk" title="Permalink to this definition">¶</a></dt>
<dd><p>Save analytical phantom to vtk, i.e paraview readable format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>) – Absolute file path ending with desired filename.</p></li>
<li><p><strong>times</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Timepoints at which to save the phantom particle ensemble.</p></li>
<li><p><strong>scale</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>, optional) – Scales the coordinates of the output. Defaults to unity.</p></li>
<li><p><strong>translation</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Translates the output ensemble, shape=(3,). Defaults to zero.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="phantom.Voxels">
<em class="property">class </em><code class="sig-prename descclassname">phantom.</code><code class="sig-name descname">Voxels</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">detector_pixel_size</span></em>, <em class="sig-param"><span class="n">number_of_detector_pixels</span></em>, <em class="sig-param"><span class="n">voxel_volume</span></em>, <em class="sig-param"><span class="n">integration_stepsize</span></em>, <em class="sig-param"><span class="n">velocity_basis</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.Voxels" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#phantom.DynamicPhantom" title="phantom.DynamicPhantom"><code class="xref py py-class docutils literal notranslate"><span class="pre">phantom.DynamicPhantom</span></code></a></p>
<p>Phantom constructed from a set of cubic voxels.</p>
<p>This phantom is constructed from quanteties used in later reconstructions, these are the
flow and ray model (<code class="xref py py-obj docutils literal notranslate"><span class="pre">FlowModel</span></code>) (<code class="xref py py-obj docutils literal notranslate"><span class="pre">RayModel</span></code>). It is usefull for defining
arbitrary density fields and flows.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>detector_pixel_size</strong> (<em>int</em>) – Size of a single detector pixel (square pixels).</p></li>
<li><p><strong>number_of_detector_pixels</strong> (<em>int</em>) – Number of pixels comprising the detector side (square detector)</p></li>
<li><p><strong>voxel_volume</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Per cell density field values, shape=(N,N,N).</p></li>
<li><p><strong>integration_stepsize</strong> (<em>float</em>) – timestepsize for propagating phantom in time numerically.</p></li>
<li><p><strong>velocity_basis</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Basis</span></code>) – Velocity basis defining the time evolution flow of the phantom.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="phantom.Voxels.detector_pixel_size">
<code class="sig-name descname">detector_pixel_size</code><a class="headerlink" href="#phantom.Voxels.detector_pixel_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Size of a single detector pixel (square pixels).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="phantom.Voxels.number_of_detector_pixels">
<code class="sig-name descname">number_of_detector_pixels</code><a class="headerlink" href="#phantom.Voxels.number_of_detector_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of pixels comprising the detector side (square detector)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="phantom.Voxels.voxel_volume">
<code class="sig-name descname">voxel_volume</code><a class="headerlink" href="#phantom.Voxels.voxel_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Per cell density field values, shape=(N,N,N).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="phantom.Voxels.integration_stepsize">
<code class="sig-name descname">integration_stepsize</code><a class="headerlink" href="#phantom.Voxels.integration_stepsize" title="Permalink to this definition">¶</a></dt>
<dd><p>timestepsize for propagating phantom in time numerically.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="phantom.Voxels.velocity_basis">
<code class="sig-name descname">velocity_basis</code><a class="headerlink" href="#phantom.Voxels.velocity_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Velocity basis defining the time evolution flow of the phantom.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Basis</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="phantom.Voxels.flow_model">
<code class="sig-name descname">flow_model</code><a class="headerlink" href="#phantom.Voxels.flow_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Flow model defining the approximate density temporal derivative.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">FlowModel</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="phantom.Voxels.get_max_cfl">
<code class="sig-name descname">get_max_cfl</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">times</span></em>, <em class="sig-param"><span class="n">dt</span></em>, <em class="sig-param"><span class="n">dx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.Voxels.get_max_cfl" title="Permalink to this definition">¶</a></dt>
<dd><p>This method overrides <code class="xref py py-meth docutils literal notranslate"><span class="pre">Phantom.get_max_cfl()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="phantom.Voxels.get_sinogram">
<code class="sig-name descname">get_sinogram</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">angles</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.Voxels.get_sinogram" title="Permalink to this definition">¶</a></dt>
<dd><p>This method implements <a class="reference internal" href="#phantom.Voxels.get_sinogram" title="phantom.Voxels.get_sinogram"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_sinogram()</span></code></a> of superclass <code class="xref py py-obj docutils literal notranslate"><span class="pre">Phantom</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="phantom.Voxels.set_velocity_coefficent_function">
<code class="sig-name descname">set_velocity_coefficent_function</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em><span class="sig-paren">)</span><a class="headerlink" href="#phantom.Voxels.set_velocity_coefficent_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a function for describing the temporal evolution of the velocity basis coefficents.</p>
<p>The flow model velocity basis coefficents, <code class="docutils literal notranslate"><span class="pre">flow_model.velocity_basis.coefficents</span></code>, are
set by the provided callable function whenever velocities are needed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>function</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code>) – <code class="docutils literal notranslate"><span class="pre">function(time)</span></code> should return a <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> with velocity
basis coefficents of shape <code class="docutils literal notranslate"><span class="pre">flow_model.velocity_basis.coefficents.shape</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-utils">
<span id="utils"></span><h2>utils<a class="headerlink" href="#module-utils" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="utils.TVD_RK3_step">
<code class="sig-prename descclassname">utils.</code><code class="sig-name descname">TVD_RK3_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dydt</span></em>, <em class="sig-param"><span class="n">t0</span></em>, <em class="sig-param"><span class="n">y0</span></em>, <em class="sig-param"><span class="n">dt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#utils.TVD_RK3_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single Third-order Strong Stability Preserving Runge-Kutta step, (SSPRK3).</p>
<p>This is a convex combination of euler forward steps which results
in a Total Variational Diminishing (TVD) step if a single euler forward
step of size dt is also TVD.</p>
<dl class="simple">
<dt>citation:</dt><dd><p><a class="reference external" href="https://doi.org/10.1090/S0025-5718-98-00913-2">Total Variation Diminishing Runge-Kutta Schemes,
Sigal Gottlieb and Chi-Wang Shu,
Methematics of Computation,
Volume 67, Number 221, January 1998, Pages 73–85</a>:</p>
</dd>
</dl>
<p>Butcher tableau can be <a class="reference external" href="https://en.wikipedia.org/wiki/List_of_Runge-Kutta_methods">found at wikipedia</a>:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dydt</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code>) – Derivative of target w.r.t time. <code class="docutils literal notranslate"><span class="pre">dydt(t,y)</span></code> should return the
temporal derivative of a Parial Differential Equation (PDE) at time t for spatial field y.</p></li>
<li><p><strong>t0</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Time at which to start integration.</p></li>
<li><p><strong>y0</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Spatial discretized field at <code class="docutils literal notranslate"><span class="pre">t0</span></code>.</p></li>
<li><p><strong>dt</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code>) – Integration steplength.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> Spatial discretized field at time <code class="docutils literal notranslate"><span class="pre">t0+dt</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="utils.downsample_sinogram">
<code class="sig-prename descclassname">utils.</code><code class="sig-name descname">downsample_sinogram</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sinogram</span></em>, <em class="sig-param"><span class="n">sampling</span></em><span class="sig-paren">)</span><a class="headerlink" href="#utils.downsample_sinogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Downsample a sinogram array by a fixed factor by forming local means.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sinogram</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Sinogram to be downsampled.</p></li>
<li><p><strong>sampling</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Downsampling factor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> downsampled sinogram.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="utils.euler_step">
<code class="sig-prename descclassname">utils.</code><code class="sig-name descname">euler_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dydt</span></em>, <em class="sig-param"><span class="n">t0</span></em>, <em class="sig-param"><span class="n">y0</span></em>, <em class="sig-param"><span class="n">dt</span></em><span class="sig-paren">)</span><a class="headerlink" href="#utils.euler_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single Euler Forward step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dydt</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code>) – Derivative of target w.r.t time. <code class="docutils literal notranslate"><span class="pre">dydt(t,y)</span></code> should return the
temporal derivative of a Parial Differential Equation (PDE) at time t for spatial field y.</p></li>
<li><p><strong>t0</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Time at which to start integration.</p></li>
<li><p><strong>y0</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Spatial discretized field at <code class="docutils literal notranslate"><span class="pre">t0</span></code>.</p></li>
<li><p><strong>dt</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code>) – Integration steplength.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> Spatial discretized field at time <code class="docutils literal notranslate"><span class="pre">t0+dt</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="utils.get_total_variation">
<code class="sig-prename descclassname">utils.</code><code class="sig-name descname">get_total_variation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">volume</span></em><span class="sig-paren">)</span><a class="headerlink" href="#utils.get_total_variation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute Total Variation of a discretized density volume.</p>
<p>The Total Variation, <span class="math notranslate nohighlight">\(TVD\)</span>, is defined as</p>
<div class="math notranslate nohighlight">
\[TVD = \int \|\dfrac{\partial \rho}{\partial x}\|_1 +
\|\dfrac{\partial \rho}{\partial y}\|_1 +
\|\dfrac{\partial \rho}{\partial z}\|_1\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho\)</span> is a spatial field and <span class="math notranslate nohighlight">\(\| \cdot \|_1\)</span> denotes
the absoulte value (<span class="math notranslate nohighlight">\(L1\)</span> norm). The parial derivaitves are implemented
as forward finite differences.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>volume</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Density field.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> Total Variation of input volume.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="utils.load_vtk_point_data">
<code class="sig-prename descclassname">utils.</code><code class="sig-name descname">load_vtk_point_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em><span class="sig-paren">)</span><a class="headerlink" href="#utils.load_vtk_point_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a vtk file containing a liggghts dem output of moving particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>file</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">arrays</span></code> with per particle, <code class="docutils literal notranslate"><span class="pre">coordinates</span></code>, <code class="docutils literal notranslate"><span class="pre">radius</span></code> and <code class="docutils literal notranslate"><span class="pre">velocity</span></code>
the format of these arrays is the same as in <a class="reference internal" href="#utils.save_as_vtk_particles" title="utils.save_as_vtk_particles"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save_as_vtk_particles()</span></code></a>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="utils.save_as_vtk_particles">
<code class="sig-prename descclassname">utils.</code><code class="sig-name descname">save_as_vtk_particles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">coordinates</span></em>, <em class="sig-param"><span class="n">velocities</span></em>, <em class="sig-param"><span class="n">radii</span></em><span class="sig-paren">)</span><a class="headerlink" href="#utils.save_as_vtk_particles" title="Permalink to this definition">¶</a></dt>
<dd><p>Save numpy arrays with particle information to paraview readable format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>) – Absolute path ending with desired filename.</p></li>
<li><p><strong>coordinates</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Coordinates of particle ensemble, shape=(N,3).</p></li>
<li><p><strong>velocities</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Velocities of particle ensemble, shape=(N,3).</p></li>
<li><p><strong>radii</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Radii of particle ensemble, shape=(N,).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="utils.save_as_vtk_voxel_volume">
<code class="sig-prename descclassname">utils.</code><code class="sig-name descname">save_as_vtk_voxel_volume</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">voxel_volume</span></em>, <em class="sig-param"><span class="n">units</span><span class="o">=</span><span class="default_value">1.0, 1.0, 1.0</span></em>, <em class="sig-param"><span class="n">origin</span><span class="o">=</span><span class="default_value">0.0, 0.0, 0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#utils.save_as_vtk_voxel_volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Save numpy array with voxel information to paraview readable format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>) – Absolute path ending with desired filename.</p></li>
<li><p><strong>voxel_volume</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Per voxel density values in a 3d array.</p></li>
<li><p><strong>units</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Distance between voxels in <code class="docutils literal notranslate"><span class="pre">`voxel_volume`</span></code> (x,y,z).</p></li>
<li><p><strong>origin</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Origin of voxel <code class="docutils literal notranslate"><span class="pre">`voxel_volume[0,0,0]`</span></code> (x,y,z).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="utils.tomographic_density_field_reconstruction">
<code class="sig-prename descclassname">utils.</code><code class="sig-name descname">tomographic_density_field_reconstruction</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">angles</span></em>, <em class="sig-param"><span class="n">sinogram</span></em>, <em class="sig-param"><span class="n">maxiter</span></em><span class="sig-paren">)</span><a class="headerlink" href="#utils.tomographic_density_field_reconstruction" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a classic tomography problem using positivity constraints and zero paddings.</p>
<p>Reconstructs a volume from sinograms enforcing positive voxel values in the reconstruction
and a zero padding along the 2 depth edge of the reconstruction. The scipy L-BFGS-B
implementation is used for solving the problem. This method is meant to be used for retrieveing
an initial volume from a full refrence scan from which further reconstruction with sparse angles
can take place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>angles</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Sinogram angles in degrees.</p></li>
<li><p><strong>sinogram</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Sinograms.</p></li>
<li><p><strong>maxiter</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Maximum number of L-BFGS-B iterations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> Reconstructed volume.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Axel Henningsson

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>